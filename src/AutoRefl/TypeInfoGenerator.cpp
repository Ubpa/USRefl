#include "TypeInfoGenerator.h"

#include <sstream>

using namespace Ubpa::USRefl;
using namespace std;

string TypeInfoGenerator::Generate(const vector<TypeMeta>& typeMetas) {
	stringstream ss;

	constexpr auto indent = "    ";

	ss
		<< "// This file is generated by Ubpa::USRefl::AutoRefl" << endl
		<< endl
		<< "#pragma once" << endl
		<< endl
		<< "#include <USRefl/USRefl.h>" << endl
		<< endl;

	for (const auto& typeMeta : typeMetas) {
		const auto fullname = typeMeta.GenerateFullName();
		const std::string tname = typeMeta.IsTemplateType() ? fullname : "Type";
		ss
			<< "template<" << typeMeta.GenerateTemplateList() << ">" << endl
			<< "struct Ubpa::USRefl::TypeInfo<" << fullname << ">" << endl
			;
		
		ss << indent << ": TypeInfoBase<" << fullname;
		auto publicBaseIndice = typeMeta.GetPublicBaseIndices();
		if(!publicBaseIndice.empty()) {
			if (publicBaseIndice.size() > 1) {
				ss << "," << endl;
				for (size_t i = 0; i < publicBaseIndice.size(); i++) {
					const auto& base = typeMeta.bases[publicBaseIndice[i]];
					ss << indent << indent << base.GenerateText();
					if (i != publicBaseIndice.size() - 1)
						ss << ",";
					ss << endl;
				}
				ss << indent;
			}
			else
				ss << ", " << typeMeta.bases.front().GenerateText();
		}
		
		ss
			<< ">" << endl
			<< "{" << endl
			;

		// name
		ss << "#ifdef UBPA_USREFL_NOT_USE_NAMEOF" << endl;

		if (typeMeta.IsTemplateType())
			ss << indent << "// [!] all instance types have the same name" << endl;
		
		ss
			<< indent << "static constexpr char name[" << (typeMeta.name.size() + 1) << "] = \"" << typeMeta.name << "\";" << endl
			<< "#endif" << endl
			;
		
		// attributes
		switch (config.attrListConstMode) {
		case Config::ConstMode::Constepxr:
			ss << indent << "static constexpr AttrList attrs = {";
			break;
		case Config::ConstMode::Const:
			ss << indent << "inline static const AttrList attrs = {";
			break;
		case Config::ConstMode::NonConst:
			ss << indent << "inline static AttrList attrs = {";
			break;
		}
		if (!typeMeta.attrs.empty()) {
			ss << endl;
			for (const auto& attr : typeMeta.attrs) {
				auto name = attr.GenerateName(
					attr.ns.empty() ?
					config.nonNamespaceAttrNameWithoutQuotation
					: !config.namespaceAttrNameWithQuotation
				);
				ss << indent << indent << "Attr {" << name;
				if (!attr.value.empty())
					ss << ", " << attr.GenerateValue(config.isAttrValueToFunction);
				ss << "}," << endl;
			}
			ss << indent;
		}
		ss << "};" << endl;
		
		// fields
		switch (config.attrListConstMode) {
		case Config::ConstMode::Constepxr:
			ss << indent << "static constexpr FieldList fields = {";
			break;
		case Config::ConstMode::Const:
			ss << indent << "inline static const FieldList fields = {";
			break;
		case Config::ConstMode::NonConst:
			ss << indent << "inline static FieldList fields = {";
			break;
		}
		if(!typeMeta.fields.empty()) {
			ss << endl;
			for (const auto& field : typeMeta.fields) {
				if (field.isTemplate)
					continue;
				
				ss << indent << indent << "Field {\"";
				// name
				ss << field.name << "\", ";
				// value
				switch (field.mode) {
				case Field::Mode::Variable: {
					ss << "&" << tname << "::" << field.name;
					break;
				}
				case Field::Mode::Function: {
					// TODO
					// - overload
					// - default value function overload
					// - constructor
					// - destructor
					// - operator
					if(typeMeta.IsOverloaded(field.name))
						ss << "static_cast<" << field.GenerateFunctionType("Type") << ">(&Type::" << field.name << ")";
					else
						ss << "&" << tname << "::" << field.name;
					break;
				}
				case Field::Mode::Value: {
					ss << tname << "::" << field.name;
					break;
				}
				}
				// attributes
				if (!field.attrs.empty() || field.mode != Field::Mode::Value && config.isInitializerAsAttr && !field.initializer.empty()) {
					ss
						<< "," << endl
						<< indent << indent << indent << "AttrList {" << endl;
					if (config.isInitializerAsAttr && !field.initializer.empty()) {
						Attr attr;
						attr.name = config.name_initializer;
						attr.ns = config.ns_initializer;
						attr.value = field.initializer;
						auto name = attr.GenerateName(
							attr.ns.empty() ?
							config.nonNamespaceAttrNameWithoutQuotation
							: !config.namespaceAttrNameWithQuotation
						);
						ss
							<< indent << indent << indent << indent
							<< "Attr {" << name << ", "
							<< attr.GenerateValue(field.GenerateSimpleFieldType(), config.isInitializerToFunction) << "}," << endl;
					}
					for (const auto& attr : field.attrs) {
						auto name = attr.GenerateName(
							attr.ns.empty() ?
							config.nonNamespaceAttrNameWithoutQuotation
							: !config.namespaceAttrNameWithQuotation
						);
						ss << indent << indent << indent << indent << "Attr {" << name;
						if (!attr.value.empty())
							ss << ", " << attr.GenerateValue(config.isAttrValueToFunction);
						ss << "}," << endl;
					}
					ss
						<< indent << indent << indent << "}" << endl
						<< indent << indent;
				}
				ss << "}," << endl;
			}
			ss << indent;
		}
		ss << "};" << endl; // end of fields
		
		ss << "};" << endl << endl; // end of TypeInfo
	}

	return ss.str();
}
