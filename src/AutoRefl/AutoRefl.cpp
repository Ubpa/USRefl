#include "AutoRefl.h"

#include <UANTLR/ParserCpp14/CPP14Lexer.h>
#include <UANTLR/ParserCpp14/CPP14Parser.h>

#include <iostream>
#include <sstream>

using namespace Ubpa::USRefl;
using namespace std;
using namespace antlr4;

string AutoRefl::Parse(string_view code) {
	// [ 1. clear ]
	typeInfos.clear();
	curNamespace.clear();
	curMetas = nullptr;
	curTypeInfo = nullptr;
	curVarInfo = nullptr;
	curAccessSpecifier = AccessSpecifier::PRIVATE;

	// [2. parse]
	ANTLRInputStream input(code.data());
	CPP14Lexer lexer(&input);
	CommonTokenStream tokens(&lexer);

	CPP14Parser parser(&tokens);
	tree::ParseTree* tree = parser.translationunit();

	tree->accept(this);

	// [3. generate]
	stringstream ss;
	const string indent = "    ";

	ss
		<< "// This file is generated by Ubpa::USRefl::AutoRefl" << endl
		<< endl
		<< "#pragma once" << endl
		<< endl
		<< "#include <USRefl/USRefl.h>" << endl
		<< endl;

	for (const auto& typeinfo : typeInfos) {
		string ns;
		for (auto a_ns : typeinfo.ns)
			ns += a_ns + "::";
		string type = ns + typeinfo.name;
		/*string codetype;
		for (size_t i = 0; i < type.size(); i++) {
			if (type[i] == ':') {
				codetype += "_";
				i++;
			}
			else
				codetype += type[i];
		}*/

		ss
			<< "template<>" << endl
			<< "struct Ubpa::USRefl::TypeInfo<" << type << ">" << endl
			<< indent << ": Ubpa::USRefl::TypeInfoBase<" << type << ">" << endl
			<< "{" << endl;

		// type attrs
		ss
			<< indent << "static constexpr AttrList attrs = {" << endl;
		for (const auto& [key, value] : typeinfo.metas) {
			ss << indent << indent
				<< "Attr {"<<
				"\"" << key << "\""
				<< (value.empty() ? "" : (", "+value))
				<< " }, " << endl;
		}
		ss
			<< indent << "};" << endl; // end AttrList

		// field
		ss
			<< indent << "static constexpr FieldList fields = {" << endl;
		// var
		for (const auto& varInfo : typeinfo.varInfos) {
			if (varInfo.access != AccessSpecifier::PUBLIC)
				continue;

			ss
				<< indent << indent
				<< "Field {"
				<< "\"" << varInfo.name << "\", "
				<< "&" << type << "::" << varInfo.name;

			if (!varInfo.metas.empty()) {
				ss
					<< "," << endl
					<< indent << indent << indent << "AttrList {" << endl;
				for (const auto& [key, value] : varInfo.metas) {
					ss << indent << indent << indent << indent
						<< "Attr {" <<
						"\"" << key << "\""
						<< (value.empty() ? "" : (", " + value))
						<< " }, " << endl;
				}
				ss
					<< indent << indent << indent << "}" << endl; // end AttrList
			}

			ss << indent << indent << "}," << endl;
		}
		// func
		for (const auto& funcInfo : typeinfo.funcInfos) {
			if (funcInfo.access != AccessSpecifier::PUBLIC)
				continue;

			ss
				<< indent << indent
				<< "Field {"
				<< "\"" << funcInfo.name << "\", "
				<< "&" << type << "::" << funcInfo.name;

			if (!funcInfo.metas.empty()) {
				ss
					<< "," << endl
					<< indent << indent << indent << "AttrList {" << endl;
				for (const auto& [key, value] : funcInfo.metas) {
					ss << indent << indent << indent << indent
						<< "Attr {" <<
						"\"" << key << "\""
						<< (value.empty() ? "" : (", " + value))
						<< " }, " << endl;
				}
				ss
					<< indent << indent << indent << "}" << endl; // end AttrList
			}

			ss << indent << indent << "}," << endl;
		}
		ss << indent << "};" << endl; // end FieldList

		ss
			<< "};" << endl; // end TypeInfo
	}

	return ss.str();
}

antlrcpp::Any AutoRefl::visitOriginalnamespacedefinition(CPP14Parser::OriginalnamespacedefinitionContext* ctx) {
	curNamespace.push_back(ctx->Identifier()->getText());
	auto result = visitChildren(ctx);
	curNamespace.pop_back();
	return result;
}

antlrcpp::Any AutoRefl::visitClassspecifier(CPP14Parser::ClassspecifierContext* ctx) {
	typeInfos.emplace_back();
	curTypeInfo = &typeInfos.back();
	curTypeInfo->ns = curNamespace;
	auto result = visitChildren(ctx);
	curTypeInfo = nullptr;
	return result;
}

antlrcpp::Any AutoRefl::visitClasshead(CPP14Parser::ClassheadContext* ctx) {
	curMetas = &curTypeInfo->metas;
	auto result = visitChildren(ctx);
	curMetas = nullptr;
	return result;
}

antlrcpp::Any AutoRefl::visitClasskey(CPP14Parser::ClasskeyContext* ctx) {
	curTypeInfo->classkey = ctx->getText();
	if (curTypeInfo->classkey == "struct")
		curAccessSpecifier = AccessSpecifier::PUBLIC;
	else
		curAccessSpecifier = AccessSpecifier::PRIVATE;

	return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitClassname(CPP14Parser::ClassnameContext* ctx) {
	curTypeInfo->name = ctx->getText();
	return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitAttribute(CPP14Parser::AttributeContext* ctx) {
	if (curMetas) {
		auto argCtx = ctx->attributeargumentclause();
		string arg = argCtx ? argCtx->balancedtokenseq()->getText() : "";
		curMetas->emplace(ctx->attributetoken()->getText(), move(arg));
	}
	return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitAccessspecifier(CPP14Parser::AccessspecifierContext* ctx) {
	auto accessStr = ctx->getText();
	if (accessStr == "public")
		curAccessSpecifier = AccessSpecifier::PUBLIC;
	else if (accessStr == "protected")
		curAccessSpecifier = AccessSpecifier::PROTECTED;
	else
		curAccessSpecifier = AccessSpecifier::PRIVATE;
	return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitMemberdeclaration(CPP14Parser::MemberdeclarationContext* ctx) {
	if (ctx->usingdeclaration()
		|| ctx->static_assertdeclaration()
		|| ctx->templatedeclaration()
		|| ctx->aliasdeclaration()
		|| ctx->emptydeclaration())
		return {};
	
	curFieldInfo.access = curAccessSpecifier;
	curMetas = &curFieldInfo.metas;
	inMember = true;

	auto result = visitChildren(ctx);

	if (curFieldInfo.isFunc) {
		curFuncInfo->metas = move(curFieldInfo.metas);
		curFuncInfo->name = move(curFieldInfo.name);
		curFuncInfo->access = curFieldInfo.access;
	}
	else {
		curVarInfo->metas = move(curFieldInfo.metas);
		curVarInfo->name = move(curFieldInfo.name);
		curVarInfo->access = curFieldInfo.access;
	}

	curVarInfo = nullptr;
	curFuncInfo = nullptr;
	curFieldInfo.metas.clear();
	curFieldInfo.name.clear();
	inMember = false;
	curMetas = nullptr;

	return result;
}

antlrcpp::Any AutoRefl::visitNoptrdeclarator(CPP14Parser::NoptrdeclaratorContext* ctx) {
	if (!inMember)
		return {};

	// not the first time to visit noptrdeclarator
	if (curFuncInfo != nullptr || curVarInfo != nullptr)
		return visitChildren(ctx);

	curFieldInfo.isFunc = ctx->parametersandqualifiers() != nullptr;
	
	if (curFieldInfo.isFunc) {
		curTypeInfo->funcInfos.emplace_back();
		curFuncInfo = &curTypeInfo->funcInfos.back();
	}else{
		curTypeInfo->varInfos.emplace_back();
		curVarInfo = &curTypeInfo->varInfos.back();
	}

	return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitParametersandqualifiers(CPP14Parser::ParametersandqualifiersContext* ctx) {
	return {}; // jump
	//return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitDeclspecifier(CPP14Parser::DeclspecifierContext* ctx) {
	if (!inMember)
		return visitChildren(ctx);

	if (curFieldInfo.isFunc)
		return {}; // TODO

	if (!ctx->typespecifier())
		curVarInfo->specifiers.push_back(ctx->getText());

	return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitUnqualifiedid(CPP14Parser::UnqualifiedidContext* ctx) {
	if (!inMember)
		return {};
	curFieldInfo.name = ctx->getText();
	
	return {};
	//return visitChildren(ctx);
}

antlrcpp::Any AutoRefl::visitFunctionbody(CPP14Parser::FunctionbodyContext* ctx) {
	return {}; // jump
	//return visitChildren(ctx);
}
